\documentclass[12pt,a4paper]{article}
\usepackage{geometry}
\usepackage{coling2020}
\usepackage{times}
\usepackage{url}
\usepackage[table,xcdraw]{xcolor}
\usepackage{datetime}
\usepackage{latexsym}
\usepackage{microtype}
\usepackage{amssymb}
\usepackage[cmex10]{amsmath}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{comment}
\usepackage{graphicx}
\usepackage{float}
\graphicspath{{Figures/EPS/}{figures/}}
\usepackage[usestackEOL]{stackengine}
\usepackage{array, tabularx, booktabs, multicol, multirow, supertabular}
\usepackage{tabulary}
\usepackage{pdfpages}
\usepackage{color}
\usepackage[misc]{ifsym}
\usepackage{enumerate}
\usepackage[shortlabels]{enumitem}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{algorithmic}
\usepackage[hidelinks, bookmarks=false]{hyperref}
\usepackage{makecell}
\usepackage{calc}
\usepackage{times}
\usepackage{latexsym}
\usepackage{longtable}
\usepackage{authblk}

\hyphenation{an-aly-sis}
\hyphenation{an-aly-ses}
\colingfinalcopy 

\newcommand*{\affaddr}[1]{#1} % No op here. Customize it for different styles.
\newcommand*{\affmark}[1][*]{\textsuperscript{#1}}

\DeclareMathOperator*{\argmin}{\arg\!\min}
\DeclareMathOperator*{\argmax}{\arg\!\max}
\graphicspath{ {./Latex/} }
\usepackage{subfiles} 

\begin{document}
\subfile{Labwork}

\newpage
\begin{center}
\textbf{Quick sort applies  divide \& conquer paradigm. }\\
\end{center}

%Alogirthm 
\begin{algorithm}
\caption{QUICKSORT ALGORITHM: }
\vspace*{.2 cm}
\begin{algorithmic}

\STATE QUICKSORT(A,p,r)
\IF { p < r}
\STATE q= PARTITION(A,p,r)
\STATE QUICKSORT(A,p,q-1)
\STATE QUICKSORT(A,q+1,r) 
\ENDIF
\end{algorithmic}
\end{algorithm}


\vspace{1 cm}

\begin{algorithm}
\caption{Partition algorithm: } 
\begin{algorithmic}
\STATE PARTITION(A,p,r)\\
\STATE x=A[r]\\
\STATE i=p-1 \\
\FOR {j=p to r-1}

\IF{ A[r] $ \leq $ x} 
\STATE i=i+1 
\ENDIF
\STATE exchange A[i] with A[j]
\ENDFOR
\STATE exchange A[i+1] with A[r]

\RETURN i+1 
 
\end{algorithmic}

\end{algorithm}


pen \& paper description of quick sort\: \\


%create table 
\begin{center}
\begin{table}[H]
\label{Array A[]}
\begin{tabular}{|l|l|l|l|l|l|}
\hline
5 & 2 & 4 & 6 & 1 & 3 \\ \hline
\end{tabular}
\end{table}
\end{center}


%analysics

\begin{table}[H]
\begin{tabular}{|l|l|l|l|l|}
\hline
STEP &
  VALUES &
  TRUE/FALSE &
  \begin{tabular}[c]{@{}l@{}}AFTER THE \\ OPERATION \\ ARRAY WILL\\  BE :\end{tabular} &
  DISCUSSION \\ \hline
1.QUICKSORT(A,p,r) &
  \begin{tabular}[c]{@{}l@{}}p=1\\ r=6\end{tabular} &
  \begin{tabular}[c]{@{}l@{}}2. p \textless  r\\ true\end{tabular} &
  5 2 4 6 1 3 &
   \\ \hline
3.q=PARTITION(A,p,r)        & \begin{tabular}[c]{@{}l@{}}p=1\\ r=6\end{tabular}                                                   &       &             &  \\ \hline
1. x=A{[}6{]}               & x=3                                                                                                 &       &             &  \\ \hline
2. i=p-1                    & i=0                                                                                                 &       &             &  \\ \hline
3.for(j=p to r-1) &
  \begin{tabular}[c]{@{}l@{}}j=1: \\ \\ if(A{[}1{]} \textless{}= x) \\    if(5 \textless{}= 3)\end{tabular} &
  false &
   &
   \\ \hline
 &
  \begin{tabular}[c]{@{}l@{}}j=2: \\ if(A{[}2{]}\textless{}=x)\\ if(2\textless{}=3) \\ \\ i=i+1 \\ i=1 \\ \\ swap(A{[}i{]},A{[}j{]})\\ swap(A{[}1{]},A{[}2{]})\end{tabular} &
  true &
  2 5 4 6 1 3 &
   \\ \hline
                            & \begin{tabular}[c]{@{}l@{}}j=3 :\\ \\ if(A{[}3{]}\textless{}=x ) \\ if(4\textless{}=3)\end{tabular} & false &             &  \\ \hline
                            & \begin{tabular}[c]{@{}l@{}}j=4: \\ if(A{[}4{]}\textless{}=x) \\ if(6\textless{}=3)\end{tabular}     & false &             &  \\ \hline
 &
  \begin{tabular}[c]{@{}l@{}}j=5: \\ if(A{[}5{]}\textless{}=x) \\ if(1\textless{}=3) \\ \\ i=i+1\\ i=2\\ swap(A{[}2{]},A{[}5{]})\end{tabular} &
  true &
  2 1 4 6 5 3 &
   \\ \hline
swap( A{[}i+1{]} ,A{[}r{]}) & swap( A{[}3{]},A{[}6{]})                                                                            &       & 2 1 3 6 5 4 &  \\ \hline
                           
\end{tabular}
\caption{}
\label{tab:my-tablecall-1}
\end{table}






\begin{table}[H]
\begin{tabular}{|l|l|
>{\columncolor[HTML]{FFFE65}}l |l|l|l|}
\hline
2 & 1 & 3 & 6 & 5 & 4 \\ \hline
\end{tabular}
\caption{}
\label{tab:my-table}
\end{table}








\textbf{After the operations pivot 3 will its right position .
before pivot element 3 all element are smaller than 3 \& after pivot element all element are greater than 3}  




\vspace{1cm }
\textbf{Time Complexity: }
1).\begin{large} \textbf{Best Case Complexity:}\end{large}  When the partitioning algorithm always chooses the middle element or near the middle element as the pivot, the best case scenario happens. Quicksorts best-case time complexity is O ($ n*logn $). The following is the best-case recurrence.


\begin{equation}
T(n) = 2T(n/2) + O(n)
\end{equation} 

2). \begin{large} \textbf{Average Case Complexity:}\end{large} This occurs when the array elements are in a disordered sequence that isn’t increasing or decreasing properly. Quicksort’s average case time complexity is $ O(n*logn) $. The following is the average-case recurrence.
\begin{equation}
O(n*logn)
\end{equation}


3). \begin{large} \textbf{Worst Case Complexity:}\end{large} The worst-case situation is when the partitioning algorithm picks the largest or smallest element as the pivot element every time. The worst-case time complexity of quicksort is O (n2). The following is the worst-case recurrence.

\begin{equation}
T(n) = T(0) + T(n-1) + O(n) 
\end{equation}





































\end{document}
